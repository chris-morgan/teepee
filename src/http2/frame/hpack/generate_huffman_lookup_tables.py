from __future__ import print_function
from collections import OrderedDict, namedtuple
import itertools

HUFFMAN_TABLE = [tuple(int(b) for b in bits) for bits in (
    "1111111111000",
    "11111111111111111011000",
    "1111111111111111111111100010",
    "1111111111111111111111100011",
    "1111111111111111111111100100",
    "1111111111111111111111100101",
    "1111111111111111111111100110",
    "1111111111111111111111100111",
    "1111111111111111111111101000",
    "111111111111111111101010",
    "111111111111111111111111111100",
    "1111111111111111111111101001",
    "1111111111111111111111101010",
    "111111111111111111111111111101",
    "1111111111111111111111101011",
    "1111111111111111111111101100",
    "1111111111111111111111101101",
    "1111111111111111111111101110",
    "1111111111111111111111101111",
    "1111111111111111111111110000",
    "1111111111111111111111110001",
    "1111111111111111111111110010",
    "111111111111111111111111111110",
    "1111111111111111111111110011",
    "1111111111111111111111110100",
    "1111111111111111111111110101",
    "1111111111111111111111110110",
    "1111111111111111111111110111",
    "1111111111111111111111111000",
    "1111111111111111111111111001",
    "1111111111111111111111111010",
    "1111111111111111111111111011",
    "010100",
    "1111111000",
    "1111111001",
    "111111111010",
    "1111111111001",
    "010101",
    "11111000",
    "11111111010",
    "1111111010",
    "1111111011",
    "11111001",
    "11111111011",
    "11111010",
    "010110",
    "010111",
    "011000",
    "00000",
    "00001",
    "00010",
    "011001",
    "011010",
    "011011",
    "011100",
    "011101",
    "011110",
    "011111",
    "1011100",
    "11111011",
    "111111111111100",
    "100000",
    "111111111011",
    "1111111100",
    "1111111111010",
    "100001",
    "1011101",
    "1011110",
    "1011111",
    "1100000",
    "1100001",
    "1100010",
    "1100011",
    "1100100",
    "1100101",
    "1100110",
    "1100111",
    "1101000",
    "1101001",
    "1101010",
    "1101011",
    "1101100",
    "1101101",
    "1101110",
    "1101111",
    "1110000",
    "1110001",
    "1110010",
    "11111100",
    "1110011",
    "11111101",
    "1111111111011",
    "1111111111111110000",
    "1111111111100",
    "11111111111100",
    "100010",
    "111111111111101",
    "00011",
    "100011",
    "00100",
    "100100",
    "00101",
    "100101",
    "100110",
    "100111",
    "00110",
    "1110100",
    "1110101",
    "101000",
    "101001",
    "101010",
    "00111",
    "101011",
    "1110110",
    "101100",
    "01000",
    "01001",
    "101101",
    "1110111",
    "1111000",
    "1111001",
    "1111010",
    "1111011",
    "111111111111110",
    "11111111100",
    "11111111111101",
    "1111111111101",
    "1111111111111111111111111100",
    "11111111111111100110",
    "1111111111111111010010",
    "11111111111111100111",
    "11111111111111101000",
    "1111111111111111010011",
    "1111111111111111010100",
    "1111111111111111010101",
    "11111111111111111011001",
    "1111111111111111010110",
    "11111111111111111011010",
    "11111111111111111011011",
    "11111111111111111011100",
    "11111111111111111011101",
    "11111111111111111011110",
    "111111111111111111101011",
    "11111111111111111011111",
    "111111111111111111101100",
    "111111111111111111101101",
    "1111111111111111010111",
    "11111111111111111100000",
    "111111111111111111101110",
    "11111111111111111100001",
    "11111111111111111100010",
    "11111111111111111100011",
    "11111111111111111100100",
    "111111111111111011100",
    "1111111111111111011000",
    "11111111111111111100101",
    "1111111111111111011001",
    "11111111111111111100110",
    "11111111111111111100111",
    "111111111111111111101111",
    "1111111111111111011010",
    "111111111111111011101",
    "11111111111111101001",
    "1111111111111111011011",
    "1111111111111111011100",
    "11111111111111111101000",
    "11111111111111111101001",
    "111111111111111011110",
    "11111111111111111101010",
    "1111111111111111011101",
    "1111111111111111011110",
    "111111111111111111110000",
    "111111111111111011111",
    "1111111111111111011111",
    "11111111111111111101011",
    "11111111111111111101100",
    "111111111111111100000",
    "111111111111111100001",
    "1111111111111111100000",
    "111111111111111100010",
    "11111111111111111101101",
    "1111111111111111100001",
    "11111111111111111101110",
    "11111111111111111101111",
    "11111111111111101010",
    "1111111111111111100010",
    "1111111111111111100011",
    "1111111111111111100100",
    "11111111111111111110000",
    "1111111111111111100101",
    "1111111111111111100110",
    "11111111111111111110001",
    "11111111111111111111100000",
    "11111111111111111111100001",
    "11111111111111101011",
    "1111111111111110001",
    "1111111111111111100111",
    "11111111111111111110010",
    "1111111111111111101000",
    "1111111111111111111101100",
    "11111111111111111111100010",
    "11111111111111111111100011",
    "11111111111111111111100100",
    "111111111111111111111011110",
    "111111111111111111111011111",
    "11111111111111111111100101",
    "111111111111111111110001",
    "1111111111111111111101101",
    "1111111111111110010",
    "111111111111111100011",
    "11111111111111111111100110",
    "111111111111111111111100000",
    "111111111111111111111100001",
    "11111111111111111111100111",
    "111111111111111111111100010",
    "111111111111111111110010",
    "111111111111111100100",
    "111111111111111100101",
    "11111111111111111111101000",
    "11111111111111111111101001",
    "1111111111111111111111111101",
    "111111111111111111111100011",
    "111111111111111111111100100",
    "111111111111111111111100101",
    "11111111111111101100",
    "111111111111111111110011",
    "11111111111111101101",
    "111111111111111100110",
    "1111111111111111101001",
    "111111111111111100111",
    "111111111111111101000",
    "11111111111111111110011",
    "1111111111111111101010",
    "1111111111111111101011",
    "1111111111111111111101110",
    "1111111111111111111101111",
    "111111111111111111110100",
    "111111111111111111110101",
    "11111111111111111111101010",
    "11111111111111111110100",
    "11111111111111111111101011",
    "111111111111111111111100110",
    "11111111111111111111101100",
    "11111111111111111111101101",
    "111111111111111111111100111",
    "111111111111111111111101000",
    "111111111111111111111101001",
    "111111111111111111111101010",
    "111111111111111111111101011",
    "1111111111111111111111111110",
    "111111111111111111111101100",
    "111111111111111111111101101",
    "111111111111111111111101110",
    "111111111111111111111101111",
    "111111111111111111111110000",
    "11111111111111111111101110",
    "111111111111111111111111111111",
)]

EOS = 256

def fill_bits(bits, leading_padding, trailing_padding):
    assert len(bits) + leading_padding + trailing_padding == 8
    leading = itertools.product(*([(0, 1)] * leading_padding))
    trailing = itertools.product(*([(0, 1)] * trailing_padding))
    for lhs, rhs in itertools.product(leading, trailing):
        yield lhs + bits + rhs

def tuple_bits_to_byte(bits):
    assert len(bits) == 8 and all(b in (0, 1) for b in bits)
    return (bits[0] << 7 |
            bits[1] << 6 |
            bits[2] << 5 |
            bits[3] << 4 |
            bits[4] << 3 |
            bits[5] << 2 |
            bits[6] << 1 |
            bits[7])

def make_table():
    return [None for i in range(256)]

all_tables = OrderedDict()
for i in range(8):
    all_tables[i] = make_table()

# Oh for an enum. Serve me right for drafting this in Python, not Rust.
class DecodeError(object):
    def encode(self, table_indexes):
        # 10000000 00000000
        return 0b1000000000000000
DecodeError = DecodeError()

class Value(namedtuple('Value', ('symbol', 'next_offset'))):
    def encode(self, table_indexes):
        assert 0 <= self.next_offset <= 7
        # 00000TTT VVVVVVVV
        return self.symbol | (self.next_offset << 8)

class Table(namedtuple('Table', ('key',))):
    def encode(self, table_indexes):
        # 0100000T TTTTTTTT
        return 0b0100000000000000 | table_indexes[self.key]

class PaddingOrTable(namedtuple('PaddingOrTable', ('key',))):
    def encode(self, table_indexes):
        # 1100000T TTTTTTTT
        return 0b1100000000000000 | table_indexes[self.key]

for offset in range(8):
    for symbol, bits in enumerate(HUFFMAN_TABLE):
        bytes = (bits[:8 - offset],
                 bits[8 - offset:16 - offset],
                 bits[16 - offset:24 - offset],
                 bits[24 - offset:32 - offset],
                 bits[32 - offset:40 - offset])
        lookup_length = (1 if not bytes[1] else
                         2 if not bytes[2] else
                         3 if not bytes[3] else
                         4 if not bytes[4] else 5)

        table_keys = (offset,
                      bytes[0],
                      bytes[0] + bytes[1],
                      bytes[0] + bytes[1] + bytes[2],
                      bytes[0] + bytes[1] + bytes[2] + bytes[3])
        for k in table_keys:
            if k is not () and k not in all_tables:
                all_tables[k] = make_table()
        tables = tuple(all_tables.get(k) for k in table_keys)

        # Work on the entries for the first byte table.
        table = tables[0]
        for b in fill_bits(bytes[0], offset, 8 - len(bytes[0]) - offset):
            k = tuple_bits_to_byte(b)
            if lookup_length == 1:
                assert table[k] is None
                table[k] = Value(symbol, (offset + len(bytes[0])) % 8)
            elif all(b == 1 for b in bytes[0]):
                if table[k] is None:
                    table[k] = PaddingOrTable(table_keys[1])
                else:
                    assert table[k] == PaddingOrTable(table_keys[1])
            elif table[k] is None:
                table[k] = Table(table_keys[1])
            else:
                assert table[k] == Table(table_keys[1])

        for i in range(1, 5):
            # Now work on the subtable for the second to fifth bytes.
            if bytes[i]:
                table = tables[i]
                for b in fill_bits(bytes[i], 0, 8 - len(bytes[i])):
                    k = tuple_bits_to_byte(b)
                    if lookup_length == i + 1:
                        assert table[k] is None
                        if symbol == EOS:
                            table[k] = DecodeError
                        else:
                            table[k] = Value(symbol, len(bytes[i]) % 8)
                    elif table[k] is None:
                        table[k] = Table(table_keys[i + 1])
                    else:
                        assert table[k] == Table(table_keys[i + 1])

#def panic(message = ''):
#    raise AssertionError(message)

kill = tuple(key for key, table in all_tables.items() if all(e == None for e in table))
for key in kill:
    del all_tables[key]
table_indexes = {key: index for index, (key, _) in enumerate(all_tables.items())}
print('static LOOKUP_TABLES: [[u16; 256]; {}] = ['.format(len(all_tables)))
for key, table in all_tables.items():
    print('    [{}],'.format(', '.join(
        str((DecodeError if e is None else e).encode(table_indexes))
        for e in table)))
print('];')
